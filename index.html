<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>スイカゲーム完全版</title>
    <style>
        /* 全体のリセットとレイアウト設定 */
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0;
            overflow: hidden; /* スクロール禁止 */
            background: linear-gradient(to bottom, #a0d0f0, #f0e0c0);
            font-family: 'Arial', sans-serif;
            user-select: none; -webkit-user-select: none; touch-action: none;
            display: flex; flex-direction: column; align-items: center;
        }

        /* アプリ全体のコンテナ（縦並び） */
        #app-container {
            display: flex; flex-direction: column;
            width: 100%; height: 100%;
            max-width: 500px; /* タブレットなどで横に伸びすぎないように */
            box-sizing: border-box;
            padding: 10px 0;
        }

        /* --- 1. 上部ヘッダー (スコア & NEXT) --- */
        #ui-header {
            flex: 0 0 70px; /* 高さ固定 */
            display: flex; justify-content: center; align-items: center;
            gap: 10px; width: 95%; margin: 0 auto 5px auto;
        }

        #score-box {
            background: rgba(255,255,255,0.9); border: 2px solid #8b4513; border-radius: 10px;
            flex: 1; height: 60px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #score-label { font-size: 10px; color: #555; font-weight: bold; }
        #score { font-size: 24px; font-weight: bold; color: #d04000; line-height: 1; }

        #next-box {
            background: rgba(255,255,255,0.6); border: 2px solid #8b4513; border-radius: 10px;
            width: 180px; height: 60px;
            display: flex; align-items: center; justify-content: center;
        }
        /* NEXTキャンバス */
        #next-row-canvas { width: 100%; height: 100%; }

        /* --- 2. 中央 ゲームエリア --- */
        #canvas-wrapper {
            flex: 1; /* 余ったスペースを全て使う */
            position: relative; width: 100%;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }
        canvas#world {
            /* アスペクト比2:3を維持しつつ、親要素に収める */
            max-width: 96%; max-height: 98%;
            width: auto; height: auto;
            aspect-ratio: 2 / 3;
            border: 4px solid #8b4513; border-radius: 15px;
            background: linear-gradient(to bottom, #fff8e7, #e0d0b0);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        /* --- 3. 下部フッター (シンカの輪) --- */
        #ui-footer {
            flex: 0 0 110px; /* 高さ固定 */
            width: 95%; margin: 5px auto 0 auto;
            background: rgba(255,255,255,0.5);
            border: 2px solid #8b4513; border-radius: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .footer-label { font-size: 12px; font-weight: bold; color: #d04000; margin-top: 2px; }
        #evolution-ring-canvas { margin-bottom: 2px; }

        /* ゲームオーバー画面 */
        #game-over-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); color: white; padding: 30px; border-radius: 20px;
            text-align: center; display: none; z-index: 100; border: 4px solid #fff; width: 80%;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

<div id="app-container">
    <div id="ui-header">
        <div id="score-box">
            <div id="score-label">SCORE</div>
            <div id="score">0</div>
        </div>
        <div id="next-box">
            <canvas id="next-row-canvas" width="180" height="60"></canvas>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="world" width="400" height="600"></canvas>
    </div>

    <div id="ui-footer">
        <div class="footer-label">シンカの輪</div>
        <canvas id="evolution-ring-canvas" width="300" height="80"></canvas>
    </div>
</div>

<div id="game-over-overlay">
    <h1 style="color:#ff5555; margin-top:0;">GAME OVER</h1>
    <p id="final-score" style="font-size:24px;">Score: 0</p>
    <button onclick="location.reload()" style="padding:15px 30px; background:#4CAF50; color:white; border:none; border-radius:10px; font-size:18px;">RETRY</button>
</div>

<script>
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          World = Matter.World;

    // フルーツ定義
    const FRUITS = [
        { label: 'cherry', radius: 15, baseColor: '#F00',   highlight: '#F55', shadow: '#C00' },      
        { label: 'strawberry', radius: 25, baseColor: '#FF5555', highlight: '#FF8888', shadow: '#DD3333' },
        { label: 'grape', radius: 35, baseColor: '#A0F',   highlight: '#C0F', shadow: '#80C' },      
        { label: 'orange', radius: 45, baseColor: '#FA0',   highlight: '#FC4', shadow: '#D80' },      
        { label: 'persimmon', radius: 55, baseColor: '#FF8800', highlight: '#FFBB33', shadow: '#DD6600' },
        { label: 'apple', radius: 65, baseColor: '#F22',   highlight: '#F55', shadow: '#D00' },      
        { label: 'pear', radius: 75, baseColor: '#FFD700', highlight: '#FFFF33', shadow: '#CCAA00' },       
        { label: 'peach', radius: 85, baseColor: '#FFC0CB', highlight: '#FFDDEE', shadow: '#EEAACC' },      
        { label: 'pineapple', radius: 95, baseColor: '#FFD700', highlight: '#FFFF33', shadow: '#CCAA00' },  
        { label: 'melon', radius: 105, baseColor: '#90EE90', highlight: '#B0FFB0', shadow: '#70CC70' },     
        { label: 'watermelon', radius: 120, baseColor: '#4CAF50', highlight: '#66BB6A', shadow: '#388E3C' } 
    ];

    const GAME_WIDTH = 400;
    const GAME_HEIGHT = 600;
    const GAME_OVER_LINE_Y = 100;

    const engine = Engine.create();
    const world = engine.world;

    // キャンバス取得
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');
    const nextRowCanvas = document.getElementById('next-row-canvas');
    const nextRowCtx = nextRowCanvas.getContext('2d');
    const ringCanvas = document.getElementById('evolution-ring-canvas');
    const ringCtx = ringCanvas.getContext('2d');

    // 壁作成
    const ground = Bodies.rectangle(200, 610, 410, 60, { isStatic: true, render: { fillStyle: '#8b4513' } });
    const leftWall = Bodies.rectangle(-10, 300, 60, 600, { isStatic: true, render: { fillStyle: '#8b4513' } });
    const rightWall = Bodies.rectangle(410, 300, 60, 600, { isStatic: true, render: { fillStyle: '#8b4513' } });
    World.add(world, [ground, leftWall, rightWall]);

    let currentFruit = null;
    let isClickable = true;
    let isGameOver = false;
    let score = 0;
    let nextQueue = []; 

    function fillQueue() {
        while(nextQueue.length < 3) {
            nextQueue.push(Math.floor(Math.random() * 3));
        }
    }
    fillQueue();

    // --- 描画ヘルパー ---
    function drawFruitShape(ctx, x, y, radius, def) {
        ctx.beginPath(); ctx.arc(x + radius*0.2, y + radius*0.2, radius*0.9, 0, Math.PI*2);
        ctx.fillStyle = def.shadow; ctx.fill();
        const grad = ctx.createRadialGradient(x - radius*0.3, y - radius*0.3, radius*0.1, x, y, radius);
        grad.addColorStop(0, def.highlight); grad.addColorStop(1, def.baseColor);
        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.fillStyle = grad; ctx.fill();
        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = "#333";
        ctx.beginPath(); ctx.arc(x - radius*0.2, y - radius*0.1, radius*0.08, 0, Math.PI*2);
        ctx.arc(x + radius*0.2, y - radius*0.1, radius*0.08, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x, y + radius*0.2, radius*0.15, 0, Math.PI);
        ctx.lineWidth = radius*0.05; ctx.strokeStyle = "#333"; ctx.stroke();
    }

    // ヘッダーのNEXT描画（横並び）
    function drawNextRow() {
        nextRowCtx.clearRect(0, 0, nextRowCanvas.width, nextRowCanvas.height);
        
        // Next (一番左・少し大きい)
        const f1 = FRUITS[nextQueue[0]];
        drawFruitShape(nextRowCtx, 35, 35, 22, f1);
        nextRowCtx.fillStyle="#333"; nextRowCtx.font="bold 10px Arial"; nextRowCtx.textAlign="center";
        nextRowCtx.fillText("NEXT", 35, 10);

        // 2nd
        const f2 = FRUITS[nextQueue[1]];
        drawFruitShape(nextRowCtx, 90, 35, 18, f2);
        nextRowCtx.fillText("2nd", 90, 10);

        // 3rd
        const f3 = FRUITS[nextQueue[2]];
        drawFruitShape(nextRowCtx, 140, 35, 15, f3);
        nextRowCtx.fillText("3rd", 140, 10);
    }

    // フッターのシンカの輪描画（横長キャンバスに円環または直線配置）
    // スマホの縦画面で円は小さいので、今回は「U字」または「横並び円弧」にして見やすくします
    function drawEvolutionRing(highlightIndex = -1) {
        ringCtx.clearRect(0, 0, ringCanvas.width, ringCanvas.height);
        
        const total = FRUITS.length;
        // 横一列に少し弧を描いて並べる
        const startX = 25;
        const endX = ringCanvas.width - 25;
        const step = (endX - startX) / (total - 1);
        const yBase = 50;

        // 線を描く
        ringCtx.beginPath();
        ringCtx.moveTo(startX, yBase);
        ringCtx.lineTo(endX, yBase);
        ringCtx.strokeStyle = '#d4aa7a';
        ringCtx.lineWidth = 4;
        ringCtx.stroke();

        FRUITS.forEach((f, i) => {
            const x = startX + step * i;
            const y = yBase;

            // ハイライト（現在の生成物）
            if (i === highlightIndex) {
                ringCtx.beginPath(); ringCtx.arc(x, y, 18, 0, Math.PI*2);
                ringCtx.fillStyle = 'rgba(255,255,0,0.6)'; ringCtx.fill();
            }
            
            // 次落ちてくるやつ
            if (nextQueue.length > 0 && i === nextQueue[0]) {
                ringCtx.beginPath(); ringCtx.arc(x, y, 16, 0, Math.PI*2);
                ringCtx.fillStyle = 'rgba(0,255,0,0.3)'; ringCtx.fill();
            }

            // フルーツ本体（小さく）
            drawFruitShape(ringCtx, x, y, 10 + i * 0.8, f); // ランクが上がると少し大きく表示
        });
    }

    // --- ゲームロジック ---
    function createCurrentFruit() {
        if (isGameOver) return;
        const index = nextQueue.shift();
        fillQueue();
        
        drawNextRow();
        drawEvolutionRing(); // 次のハイライト更新

        const f = FRUITS[index];
        currentFruit = Bodies.circle(200, 40, f.radius, {
            label: index.toString(), isStatic: true, restitution: 0.2
        });
        World.add(world, currentFruit);
        isClickable = true;
    }

    function dropCurrentFruit() {
        if (!currentFruit || !isClickable || isGameOver) return;
        isClickable = false;
        Matter.Body.setStatic(currentFruit, false);
        setTimeout(createCurrentFruit, 800);
    }

    function checkGameOver() {
        if (isGameOver) return;
        const bodies = Composite.allBodies(world);
        for (let body of bodies) {
            if (body.isStatic || body === currentFruit) continue;
            if (body.position.y < GAME_OVER_LINE_Y && body.speed < 0.2) {
                isGameOver = true;
                document.getElementById('final-score').innerText = "Score: " + score;
                document.getElementById('game-over-overlay').style.display = "block";
                break;
            }
        }
    }

    Events.on(engine, 'collisionStart', (event) => {
        if (isGameOver) return;
        event.pairs.forEach(pair => {
            const { bodyA, bodyB } = pair;
            if (bodyA.label && bodyB.label && bodyA.label === bodyB.label) {
                if (bodyA.isSensor || bodyB.isSensor) return;
                
                const index = parseInt(bodyA.label);
                World.remove(world, [bodyA, bodyB]);
                bodyA.isSensor = true; bodyB.isSensor = true;
                
                const mx = (bodyA.position.x + bodyB.position.x) / 2;
                const my = (bodyA.position.y + bodyB.position.y) / 2;

                if (index < FRUITS.length - 1) {
                    const newIndex = index + 1;
                    const f = FRUITS[newIndex];
                    // 壁抜け補正
                    let sx = mx; 
                    if(sx < f.radius+10) sx = f.radius+15;
                    if(sx > GAME_WIDTH - f.radius - 10) sx = GAME_WIDTH - f.radius - 15;

                    const newBody = Bodies.circle(sx, my, f.radius, {
                        label: newIndex.toString(), restitution: 0.2
                    });
                    World.add(world, newBody);
                    score += (index + 1) * 10;
                    drawEvolutionRing(newIndex); // 進化したフルーツをハイライト
                } else {
                    score += 500; 
                }
                document.getElementById('score').innerText = score;
            }
        });
    });

    Events.on(engine, 'afterUpdate', checkGameOver);

    // --- 入力処理 (座標変換) ---
    function getInternalX(clientX) {
        const rect = canvas.getBoundingClientRect();
        const scale = GAME_WIDTH / rect.width; 
        let x = (clientX - rect.left) * scale;
        const r = currentFruit ? currentFruit.circleRadius : 20;
        if (x < r + 10) x = r + 10;
        if (x > GAME_WIDTH - r - 10) x = GAME_WIDTH - r - 10;
        return x;
    }

    function handleInputMove(clientX) {
        if (!currentFruit || !isClickable || isGameOver) return;
        const x = getInternalX(clientX);
        Matter.Body.setPosition(currentFruit, { x: x, y: 40 });
    }

    window.addEventListener('mousemove', (e) => handleInputMove(e.clientX));
    canvas.addEventListener('click', () => dropCurrentFruit());

    window.addEventListener('touchmove', (e) => {
        if (e.touches.length > 0) handleInputMove(e.touches[0].clientX);
    }, { passive: false });

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length > 0) handleInputMove(e.touches[0].clientX);
    }, { passive: false });

    window.addEventListener('touchend', () => dropCurrentFruit());

    // --- メインループ ---
    (function renderLoop() {
        const bodies = Composite.allBodies(world);
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // ゲームオーバーライン
        if (!isGameOver) {
            ctx.beginPath(); ctx.moveTo(0, GAME_OVER_LINE_Y); ctx.lineTo(GAME_WIDTH, GAME_OVER_LINE_Y);
            ctx.strokeStyle = 'rgba(255,0,0,0.4)'; ctx.setLineDash([5, 10]); ctx.stroke(); ctx.setLineDash([]);
        }

        bodies.forEach(body => {
            if (body.render.visible === false) return;
            if (body.circleRadius) {
                const f = FRUITS[parseInt(body.label)];
                if (f) drawFruitShape(ctx, body.position.x, body.position.y, body.circleRadius, f);
            } else {
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(body.bounds.min.x, body.bounds.min.y, body.bounds.max.x - body.bounds.min.x, body.bounds.max.y - body.bounds.min.y);
            }
        });
        Engine.update(engine, 1000 / 60);
        requestAnimationFrame(renderLoop);
    })();

    // 初期実行
    fillQueue();
    drawNextRow();
    drawEvolutionRing();
    createCurrentFruit();
</script>
</body>
</html>