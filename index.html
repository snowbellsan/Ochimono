<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>ãŠã¡ã‚‚ã®ã±ãšã‚‹</title>
    <style>
        /* å…¨ä½“ã®ãƒªã‚»ãƒƒãƒˆã¨ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š */
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            user-select: none; -webkit-user-select: none; 
            display: block;
        }
        
        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾ç­–ã¨ã—ã¦ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä¸­å¤®ã«é…ç½®ã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’è¿½åŠ  */
        #app-outer-wrapper {
            display: flex; 
            flex-direction: column; 
            align-items: center;
            width: 100%; 
            height: 100vh; /* ä¿®æ­£: é«˜ã•å›ºå®š */
            overflow: hidden; /* è¿½åŠ : ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¦æ­¢ */
        }
        
        @keyframes scorePopup {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: #ffeb3b; }
            100% { transform: scale(1); }
        }
        
        .score-animate {
            animation: scorePopup 0.3s ease;
        }

        /* ã‚¢ãƒ—ãƒªã‚³ãƒ³ãƒ†ãƒŠ */
        #app-container {
            display: flex; flex-direction: column;
            width: 100%; 
            max-width: 500px;
            box-sizing: border-box;
            padding: 10px 0;
            flex-grow: 1; /* è¿½åŠ : å¤–å´ãƒ©ãƒƒãƒ‘ãƒ¼ã®é«˜ã•ã«åˆã‚ã›ã¦åºƒãŒã‚‹ */
            height: 100%; /* è¿½åŠ : è¦ªã®é«˜ã•100%ã«åˆã‚ã›ã‚‹ */
        }
        
        /* ãƒ˜ãƒƒãƒ€ãƒ¼ã¯å›ºå®šã®é«˜ã• */
        #ui-header {
            flex: 0 0 70px;
            display: flex; justify-content: center; align-items: center;
            gap: 10px; width: 95%; margin: 0 auto 5px auto;
        }

        #score-box {
            background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
            border: 3px solid #ffb74d; border-radius: 15px;
            flex: 1; height: 60px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #score-label { font-size: 11px; color: #666; font-weight: bold; letter-spacing: 1px; }
        #score { font-size: 28px; font-weight: bold; color: #ff6f00; line-height: 1; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }

        #next-box {
            background: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(240,240,240,0.9) 100%);
            border: 3px solid #ffb74d; border-radius: 15px;
            width: 180px; height: 60px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #next-row-canvas { width: 100%; height: 100%; }

        /* ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒ©ãƒƒãƒ‘ãƒ¼ */
        #canvas-wrapper {
            flex: 1 1 auto; /* æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’å…¨ã¦å æœ‰ */
            position: relative; width: 100%;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
            /* min-height: 300px; ã‚’å‰Šé™¤ã—ã¦æŸ”è»Ÿæ€§ã‚’ç¢ºä¿ */
        }
        canvas#world {
            max-width: 96%; 
            max-height: 100%;
            width: auto; 
            height: auto;
            aspect-ratio: 2 / 3;
            border: 5px solid #ff9800; border-radius: 20px;
            background: #ffe0b2; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.5);
            /* ã“ã“ã« touch-action: none; ã‚’é©ç”¨ã—ã€ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æŠ‘åˆ¶ */
            touch-action: none; 
        }

        /* æˆé•·ãƒ©ã‚¤ãƒ³ï¼ˆãƒ•ãƒƒã‚¿ãƒ¼ï¼‰ */
        #ui-footer {
            flex: 0 0 auto;
            width: 95%; margin: 5px auto; /* ä¿®æ­£: ä¸Šä¸‹ãƒãƒ¼ã‚¸ãƒ³ã‚’æœ€å°é™ã« (5pxãšã¤) */
            background: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(240,240,240,0.8) 100%);
            border: 3px solid #ffb74d; border-radius: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            padding: 2px 0 3px 0; /* ä¿®æ­£: ä¸Šä¸‹ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’æœ€å°é™ã« */
        }
        .footer-label { font-size: 13px; font-weight: bold; color: #ff6f00; margin-top: 2px; letter-spacing: 1px; }
        #evolution-ring-canvas { margin-bottom: 2px; }

        #game-over-overlay {
            position: fixed;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(30,30,30,0.98) 0%, rgba(0,0,0,0.95) 100%);
            color: white; padding: 40px; border-radius: 25px;
            text-align: center; display: none; z-index: 100;
            border: 4px solid #ff5252; width: 80%; max-width: 350px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

<div id="app-outer-wrapper"> <div id="app-container">
    <div id="ui-header">
        <div id="score-box">
            <div id="score-label">SCORE</div>
            <div id="score">0</div>
        </div>
        <div id="next-box">
            <canvas id="next-row-canvas" width="180" height="60"></canvas>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="world" width="400" height="600"></canvas>
    </div>

    <div id="ui-footer">
        <div class="footer-label">æˆé•·ãƒ©ã‚¤ãƒ³</div>
        <canvas id="evolution-ring-canvas" width="300" height="80"></canvas>
    </div>
</div>
</div> <div id="game-over-overlay">
    <h1 style="color:#ff5555; margin-top:0;">GAME OVER</h1>
    <p id="final-score" style="font-size:24px;">Score: 0</p>
    <button onclick="location.reload()" style="padding:15px 30px; background:#4CAF50; color:white; border:none; border-radius:10px; font-size:18px; cursor:pointer;">RETRY</button>
</div>

<script>
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          World = Matter.World;

    // ã‚²ãƒ¼ãƒ å®šæ•°
    const GAME_WIDTH = 400;
    const GAME_HEIGHT = 600;
    const GAME_OVER_LINE_Y = 100;
    const DROP_DELAY = 800;
    const GAMEOVER_CHECK_TIME = 2000;
    const WALL_THICKNESS = 60;
	
	// ğŸµ BGMèª­ã¿è¾¼ã¿ï¼†ãƒ«ãƒ¼ãƒ—è¨­å®š
    const bgm = new Audio("assets/for_Life.mp3");
    bgm.loop = true;
    bgm.volume = 0.3; // ãŠå¥½ã¿ã§â™ª
	
	// ğŸµ åˆä½“éŸ³
    const seMerge = new Audio("assets/ã±ã£.mp3");
    seMerge.volume = 0.9;


    // è™¹è‰²ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãŠã‚ˆã³æ°´é¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¿ã‚¤ãƒãƒ¼
    let rainbowTime = 0; 
    let waterTime = 0; // æ°´é¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨å¤‰æ•°

    // ã‚«ãƒ©ãƒ•ãƒ«ãƒœãƒ¼ãƒ«å®šç¾©ï¼ˆæœ€å¤§ãƒœãƒ¼ãƒ«ã‚’è™¹è‰²ã«å¤‰æ›´ï¼‰
    const BALLS = [
        { label: 'blue', radius: 15, baseColor: '#2196F3', highlight: '#64B5F6', shadow: '#1565C0', score: 10 },
        { label: 'skyblue', radius: 25, baseColor: '#00BCD4', highlight: '#4DD0E1', shadow: '#0097A7', score: 20 },
        { label: 'purple', radius: 35, baseColor: '#9c27b0', highlight: '#ce93d8', shadow: '#6a1b9a', score: 30 },
        { label: 'orange', radius: 45, baseColor: '#ff9800', highlight: '#ffcc80', shadow: '#f57c00', score: 50 },
        { label: 'orange2', radius: 55, baseColor: '#ff6f00', highlight: '#ffab40', shadow: '#e65100', score: 80 },
        { label: 'red', radius: 65, baseColor: '#f44336', highlight: '#ef5350', shadow: '#d32f2f', score: 120 },
        { label: 'yellow', radius: 75, baseColor: '#fdd835', highlight: '#ffee58', shadow: '#f9a825', score: 170 },
        { label: 'pink', radius: 85, baseColor: '#ffb3d9', highlight: '#ffd4e5', shadow: '#ff80ab', score: 230 },
        { label: 'yelloworange', radius: 95, baseColor: '#ffc107', highlight: '#ffe082', shadow: '#ffa000', score: 300 },
        { label: 'lightgreen', radius: 105, baseColor: '#66bb6a', highlight: '#a5d6a7', shadow: '#43a047', score: 380 },
        // è™¹è‰²ãƒœãƒ¼ãƒ« (ã‚¢ãƒ‹ãƒ’ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¯¾è±¡)
        { label: 'rainbow', radius: 120, baseColor: 'rainbow', highlight: 'rainbow', shadow: 'rainbow', score: 1000 }
    ];

    const engine = Engine.create();
    const world = engine.world;
    engine.world.gravity.y = 1.2;

    // ã‚­ãƒ£ãƒ³ãƒã‚¹å–å¾—
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');
    const nextRowCanvas = document.getElementById('next-row-canvas');
    const nextRowCtx = nextRowCanvas.getContext('2d');
    const ringCanvas = document.getElementById('evolution-ring-canvas');
    const ringCtx = ringCanvas.getContext('2d');

    // å£ä½œæˆï¼ˆç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ”¹å–„ï¼‰
    const ground = Bodies.rectangle(GAME_WIDTH/2, GAME_HEIGHT + 10, GAME_WIDTH + 20, WALL_THICKNESS, {
        isStatic: true, friction: 0.8, restitution: 0.1
    });
    const leftWall = Bodies.rectangle(-10, GAME_HEIGHT/2, WALL_THICKNESS, GAME_HEIGHT, {
        isStatic: true, friction: 0.8, restitution: 0.1
    });
    const rightWall = Bodies.rectangle(GAME_WIDTH + 10, GAME_HEIGHT/2, WALL_THICKNESS, GAME_HEIGHT, {
        isStatic: true, friction: 0.8, restitution: 0.1
    });
    World.add(world, [ground, leftWall, rightWall]);

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let currentFruit = null;
    let isClickable = true;
    let isGameOver = false;
    let score = 0;
    let nextQueue = [];
    let particles = [];
    let bodiesAboveLine = new Map();

    // ã‚­ãƒ¥ãƒ¼ç®¡ç†
    function fillQueue() {
        while(nextQueue.length < 3) {
            nextQueue.push(Math.floor(Math.random() * 3));
        }
    }
    fillQueue();

    // --- ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ  ---
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = (Math.random() - 0.5) * 8 - 2;
            this.life = 1.0;
            this.color = color;
            this.size = Math.random() * 6 + 3;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.3;
            this.life -= 0.02;
            return this.life > 0;
        }
        
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function createParticles(x, y, color, count = 15) {
        for(let i = 0; i < count; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    // --- è™¹è‰²ãƒœãƒ¼ãƒ«å°‚ç”¨æç”» ---
    function drawRainbowFruit(ctx, x, y, radius, time) {
        // 1. å½±ã¨å…‰ã®è„ˆå‹•åŠ¹æœ
        ctx.save();
        const pulse = Math.sin(time * 0.2) * 0.5 + 0.5; // 0.0 to 1.0
        // è™¹è‰²ã®å…‰ã‚’æ”¾ã¤
        ctx.shadowColor = `rgba(255, 255, 255, ${0.5 + pulse * 0.5})`;
        ctx.shadowBlur = 10 + pulse * 15;

        // 2. è™¹è‰²ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ”¾å°„çŠ¶ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ï¼‰
        const gradient = ctx.createRadialGradient(x, y, radius * 0.1, x, y, radius);
        const colors = ["#ff0000", "#ff7f00", "#ffff00", "#00ff00", "#0000ff", "#4b0082", "#9400d3"];
        
        // æ™‚é–“ã§è‰²ã‚’ãšã‚‰ã™
        const colorShift = Math.floor(time / 2) % colors.length;
        
        colors.forEach((color, i) => {
             // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹å§‹ä½ç½®ã‚’æ™‚é–“ã§å¤‰ãˆã¦å‹•ã„ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ã›ã‚‹
            gradient.addColorStop((i + colorShift) % colors.length / colors.length, color);
        });

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // 3. ç™½ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 + pulse * 0.2})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        // 4. é¡”ï¼ˆæ¨™æº–ã®é¡”ï¼‰
        ctx.fillStyle = "#1a1a1a";
        ctx.beginPath();
        ctx.arc(x - radius*0.25, y - radius*0.1, radius*0.1, 0, Math.PI*2);
        ctx.arc(x + radius*0.25, y - radius*0.1, radius*0.1, 0, Math.PI*2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(x, y + radius*0.15, radius*0.2, 0, Math.PI);
        ctx.lineWidth = radius*0.08;
        ctx.strokeStyle = "#1a1a1a";
        ctx.stroke();

        ctx.restore();
    }
    
    // --- æç”»ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯å¼·åŒ–ç‰ˆï¼‰ ---
    function drawBALLShape(ctx, x, y, radius, def) {
        // è™¹è‰²ãƒœãƒ¼ãƒ«åˆ¤å®š
        if (def.label === 'rainbow') {
            drawRainbowFruit(ctx, x, y, radius, rainbowTime);
            return;
        }

        // å½±
        ctx.save();
        ctx.beginPath();
        ctx.arc(x + radius*0.15, y + radius*0.15, radius*0.95, 0, Math.PI*2);
        ctx.fillStyle = def.shadow;
        ctx.globalAlpha = 0.4;
        ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.restore();
        
        // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚Šç«‹ä½“çš„ã«ï¼‰
        const grad = ctx.createRadialGradient(
            x - radius*0.35, y - radius*0.35, radius*0.1,
            x, y, radius
        );
        grad.addColorStop(0, def.highlight);
        grad.addColorStop(0.6, def.baseColor);
        grad.addColorStop(1, def.shadow);
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();
        
        // å¤–æ ï¼ˆè¼ªéƒ­å¼·èª¿ï¼‰
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆå…‰æ²¢ï¼‰
        const highlight = ctx.createRadialGradient(
            x - radius*0.3, y - radius*0.3, 0,
            x - radius*0.3, y - radius*0.3, radius*0.5
        );
        highlight.addColorStop(0, 'rgba(255,255,255,0.8)');
        highlight.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.beginPath();
        ctx.arc(x - radius*0.25, y - radius*0.25, radius*0.4, 0, Math.PI*2);
        ctx.fillStyle = highlight;
        ctx.fill();
        
        // é¡”ï¼ˆç›®ã¨å£ï¼‰
        ctx.fillStyle = "#1a1a1a";
        ctx.beginPath();
        ctx.arc(x - radius*0.25, y - radius*0.1, radius*0.1, 0, Math.PI*2);
        ctx.arc(x + radius*0.25, y - radius*0.1, radius*0.1, 0, Math.PI*2);
        ctx.fill();
        
        // ç¬‘é¡”
        ctx.beginPath();
        ctx.arc(x, y + radius*0.15, radius*0.2, 0, Math.PI);
        ctx.lineWidth = radius*0.08;
        ctx.strokeStyle = "#1a1a1a";
        ctx.stroke();
    }

    // ãƒ˜ãƒƒãƒ€ãƒ¼ã®NEXTæç”»ï¼ˆæ¨ªä¸¦ã³ï¼‰
    function drawNextRow() {
        nextRowCtx.clearRect(0, 0, nextRowCanvas.width, nextRowCanvas.height);
        
        const positions = [
            { x: 35, y: 35, size: 22, label: "NEXT" },
            { x: 90, y: 35, size: 18, label: "2nd" },
            { x: 140, y: 35, size: 15, label: "3rd" }
        ];
        
        positions.forEach((pos, i) => {
            if (i < nextQueue.length) {
                const f = BALLS[nextQueue[i]];
                drawBALLShape(nextRowCtx, pos.x, pos.y, pos.size, f);
                nextRowCtx.fillStyle = "#333";
                nextRowCtx.font = "bold 10px Arial";
                nextRowCtx.textAlign = "center";
                nextRowCtx.fillText(pos.label, pos.x, 10);
            }
        });
    }

    // ãƒ•ãƒƒã‚¿ãƒ¼ã®æˆé•·ãƒ©ã‚¤ãƒ³æç”»
    function drawEvolutionRing(highlightIndex = -1) {
        ringCtx.clearRect(0, 0, ringCanvas.width, ringCanvas.height);
        
        const total = BALLS.length;
        const startX = 25;
        const endX = ringCanvas.width - 25;
        const step = (endX - startX) / (total - 1);
        const yBase = 50;

        // æ¥ç¶šç·šï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
        const lineGrad = ringCtx.createLinearGradient(startX, 0, endX, 0);
        lineGrad.addColorStop(0, '#ff9800');
        lineGrad.addColorStop(0.5, '#ffc107');
        lineGrad.addColorStop(1, '#ff9800');
        
        ringCtx.beginPath();
        ringCtx.moveTo(startX, yBase);
        ringCtx.lineTo(endX, yBase);
        ringCtx.strokeStyle = lineGrad;
        ringCtx.lineWidth = 5;
        ringCtx.stroke();

        BALLS.forEach((f, i) => {
            const x = startX + step * i;
            const y = yBase;

            // ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆç¾åœ¨ã®ç”Ÿæˆç‰©ï¼‰
            if (i === highlightIndex) {
                ringCtx.save();
                ringCtx.shadowColor = '#ffeb3b';
                ringCtx.shadowBlur = 20;
                ringCtx.beginPath();
                ringCtx.arc(x, y, 18, 0, Math.PI*2);
                ringCtx.fillStyle = 'rgba(255,235,59,0.6)';
                ringCtx.fill();
                ringCtx.restore();
            }
            
            // æ¬¡è½ã¡ã¦ãã‚‹ã‚„ã¤
            if (nextQueue.length > 0 && i === nextQueue[0]) {
                ringCtx.beginPath();
                ringCtx.arc(x, y, 16, 0, Math.PI*2);
                ringCtx.strokeStyle = '#4caf50';
                ringCtx.lineWidth = 3;
                ringCtx.stroke();
            }

            // ã‚«ãƒ©ãƒ•ãƒ«ãƒœãƒ¼ãƒ«æœ¬ä½“
            const size = 8 + i * 1.2;
            drawBALLShape(ringCtx, x, y, size, f);
        });
    }

    // ã‚¹ã‚³ã‚¢æ›´æ–°ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
    function updateScore(points) {
        score += points;
        const scoreEl = document.getElementById('score');
        scoreEl.innerText = score;
        scoreEl.classList.add('score-animate');
        setTimeout(() => scoreEl.classList.remove('score-animate'), 300);
    }

    // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ ---
    function createCurrentFruit() {
        if (isGameOver) return;
        const index = nextQueue.shift();
        fillQueue();
        
        drawNextRow();
        drawEvolutionRing();

        const f = BALLS[index];
        currentFruit = Bodies.circle(GAME_WIDTH/2, 40, f.radius, {
            label: index.toString(),
            isStatic: true,
            restitution: 0.3,
            friction: 0.5,
            density: 0.001,
            frictionAir: 0.01
        });
        World.add(world, currentFruit);
        isClickable = true;
    }

    function dropCurrentFruit() {
        if (!currentFruit || !isClickable || isGameOver) return;
        isClickable = false;
        Matter.Body.setStatic(currentFruit, false);
        
        // ãƒ‰ãƒ­ãƒƒãƒ—éŸ³åŠ¹æœï¼ˆè¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼‰
        const f = BALLS[parseInt(currentFruit.label)];
        createParticles(currentFruit.position.x, currentFruit.position.y, f.baseColor, 5);
        
        setTimeout(createCurrentFruit, DROP_DELAY);
    }

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
    function checkGameOver() {
        if (isGameOver) return;
        
        const bodies = Composite.allBodies(world);
        const now = Date.now();
        
        // ãƒ©ã‚¤ãƒ³ä¸Šã®ãƒœãƒ‡ã‚£ã‚’ãƒã‚§ãƒƒã‚¯
        for (let body of bodies) {
            if (body.isStatic || body === currentFruit) continue;
            
            // æ°´é¢ãŒã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ³ã‚’å…¼ã­ã‚‹
            if (body.position.y - body.circleRadius < GAME_OVER_LINE_Y) { 
                if (!bodiesAboveLine.has(body.id)) {
                    bodiesAboveLine.set(body.id, now);
                }
                else if (now - bodiesAboveLine.get(body.id) > GAMEOVER_CHECK_TIME) {
                    if (body.speed < 0.5) {
                        triggerGameOver();
                        return;
                    }
                }
            } else {
                bodiesAboveLine.delete(body.id);
            }
        }
    }

    function triggerGameOver() {
        isGameOver = true;
        document.getElementById('final-score').innerText = "Score: " + score;
        document.getElementById('game-over-overlay').style.display = "block";
    }

    // è¡çªã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¯¾æ¶ˆæ»…ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ ï¼‰
    Events.on(engine, 'collisionStart', (event) => {
        if (isGameOver) return;
        
        event.pairs.forEach(pair => {
            const { bodyA, bodyB } = pair;
            
            // åŒã˜ã‚«ãƒ©ãƒ•ãƒ«ãƒœãƒ¼ãƒ«åŒå£«ã®è¡çªåˆ¤å®š
            if (bodyA.label && bodyB.label && bodyA.label === bodyB.label) {
                // æ—¢ã«å‡¦ç†æ¸ˆã¿ã¾ãŸã¯å‰Šé™¤äºˆå®šã®ãƒœãƒ‡ã‚£ã¯ç„¡è¦–
                if (bodyA.isSensor || bodyB.isSensor) return;
                if (!Composite.get(world, bodyA.id, 'body') || !Composite.get(world, bodyB.id, 'body')) return;
                
                const index = parseInt(bodyA.label);
                const rainbowIndex = BALLS.length - 1;

                // å‰Šé™¤ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                bodyA.isSensor = true;
                bodyB.isSensor = true;
                
                // ãƒ¯ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰å‰Šé™¤
                World.remove(world, [bodyA, bodyB]);
                
                const mx = (bodyA.position.x + bodyB.position.x) / 2;
                const my = (bodyA.position.y + bodyB.position.y) / 2;

                if (index < rainbowIndex) {
                    // é€šå¸¸ã®é€²åŒ– (è™¹è‰²ãƒœãƒ¼ãƒ«æœªæº€)
                    const newIndex = index + 1;
                    const f = BALLS[newIndex];
                    
                    let sx = mx;
                    const minX = f.radius + 15;
                    const maxX = GAME_WIDTH - f.radius - 15;
                    sx = Math.max(minX, Math.min(maxX, sx));

                    const newBody = Bodies.circle(sx, my, f.radius, {
                        label: newIndex.toString(),
                        restitution: 0.3,
                        friction: 0.5,
                        density: 0.001,
                        frictionAir: 0.01
                    });
                    World.add(world, newBody);
                    
                    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨ã‚¹ã‚³ã‚¢
                    createParticles(mx, my, f.baseColor, 20);
                    updateScore(f.score);
                    drawEvolutionRing(newIndex);
					
					// â˜… åŠ¹æœéŸ³ã‚’é³´ã‚‰ã™
                    seMerge.currentTime = 0; // é€£ç¶šå†ç”Ÿç”¨ãƒªã‚»ãƒƒãƒˆ
                    seMerge.play();
                } else {
                    // è™¹è‰²ãƒœãƒ¼ãƒ«åŒå£«ã®å¯¾æ¶ˆæ»… (Annihilation) ãƒ­ã‚¸ãƒƒã‚¯
                    const annihilationScore = BALLS[index].score * 5; // 5å€ã®ãƒœãƒ¼ãƒŠã‚¹ (5000ç‚¹)
                    
                    createParticles(mx, my, '#ffffff', 80); // é–ƒå…‰
                    createParticles(mx, my, '#ff0000', 40); // è™¹è‰²ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    createParticles(mx, my, '#0000ff', 40);
                    
                    updateScore(annihilationScore);
                }
            }
        });
    });

    Events.on(engine, 'afterUpdate', checkGameOver);

    // --- å…¥åŠ›å‡¦ç†ï¼ˆåº§æ¨™å¤‰æ› + ãƒ‰ãƒ­ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ï¼‰ ---
    let scaleFactor = 1;
    function calculateScaleFactor() {
        const rect = canvas.getBoundingClientRect();
        const wrapper = document.getElementById('canvas-wrapper');
        const wrapperRect = wrapper.getBoundingClientRect();

        const ratio = GAME_WIDTH / GAME_HEIGHT;
        let effectiveWidth = wrapperRect.height * ratio;
        let effectiveHeight = wrapperRect.height;

        if (effectiveWidth > wrapperRect.width) {
            effectiveWidth = wrapperRect.width;
            effectiveHeight = effectiveWidth / ratio;
        }
        
        const currentDisplayWidth = rect.width;
        scaleFactor = GAME_WIDTH / currentDisplayWidth;
    }
    
    window.addEventListener('resize', calculateScaleFactor);

    function getInternalX(clientX) {
        const rect = canvas.getBoundingClientRect();
        let x = (clientX - rect.left) * scaleFactor; 
        
        if (currentFruit) {
            const r = currentFruit.circleRadius;
            const minX = r + 10;
            const maxX = GAME_WIDTH - r - 10;
            x = Math.max(minX, Math.min(maxX, x));
        }
        return x;
    }

    function handleInputMove(clientX) {
        if (!currentFruit || !isClickable || isGameOver) return;
        const x = getInternalX(clientX);
        Matter.Body.setPosition(currentFruit, { x: x, y: 40 });
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    window.addEventListener('load', calculateScaleFactor); 
    
    // ãƒã‚¦ã‚¹æ“ä½œã¯å¼•ãç¶šãã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å…¨ä½“ã§å—ã‘ä»˜ã‘ã‚‹ï¼ˆPCã§ã®æ“ä½œæ€§ç¶­æŒã®ãŸã‚ï¼‰
    window.addEventListener('mousemove', (e) => handleInputMove(e.clientX));
    
    // ã‚¯ãƒªãƒƒã‚¯ãƒ»ã‚¿ãƒƒãƒ—ã§ã®ãƒ‰ãƒ­ãƒƒãƒ—ã¯ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã§å®Ÿè¡Œ
    canvas.addEventListener('click', () => dropCurrentFruit());

    // ***** å¤‰æ›´ç‚¹: ã‚¿ãƒƒãƒæ“ä½œã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®ã¿ã«é™å®š *****

    // touch START: ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã§æ“ä½œã‚’é–‹å§‹ã—ãŸã¨ãã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²æ­¢ã—ã€ä½ç½®ã‚’èª¿æ•´
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length > 0) {
            e.preventDefault(); 
            handleInputMove(e.touches[0].clientX);
        }
    }, { passive: false });

    // touch MOVE: ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã„ã‚‹é–“ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²æ­¢ã—ã€ä½ç½®ã‚’èª¿æ•´
    canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length > 0) {
            e.preventDefault(); 
            handleInputMove(e.touches[0].clientX);
        }
    }, { passive: false });

    // touch END: ãƒ‰ãƒ­ãƒƒãƒ—
    canvas.addEventListener('touchend', (e) => {
        dropCurrentFruit();
        // e.preventDefault() ã¯ä¸è¦ã€‚ã‚¿ãƒƒãƒçµ‚äº†å¾Œã®æ¨™æº–å‹•ä½œã‚’å¦¨ã’ãªã„ã€‚
    }, { passive: false });


    // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ï¼ˆæ°´ã®æç”»ã‚’å†è¿½åŠ ï¼‰ ---
    let lastTime = Date.now();
    
    (function renderLoop() {
        const now = Date.now();
        const delta = now - lastTime;
        lastTime = now;
        
        rainbowTime += 0.05; // è™¹è‰²ãƒœãƒ¼ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚¿ã‚¤ãƒãƒ¼
        waterTime += 0.05; // æ°´é¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ»‘ã‚‰ã‹ã«ã™ã‚‹ãŸã‚ã®æ›´æ–°
        
        const bodies = Composite.allBodies(world);
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        
        // --- æ°´ã®æç”» ---
        const WATER_LEVEL = GAME_OVER_LINE_Y;
        const WAVE_AMPLITUDE = 5;
        const WAVE_FREQUENCY = 0.05;
        const SEGMENTS = 20; 

        ctx.save();
        
        // 1. æ°´ã®åº•ã‚’æç”»ï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
        const waterGrad = ctx.createLinearGradient(0, WATER_LEVEL, 0, GAME_HEIGHT);
        waterGrad.addColorStop(0, 'rgba(100, 150, 255, 0.5)'); 
        waterGrad.addColorStop(1, 'rgba(0, 50, 150, 0.8)');   
        
        ctx.beginPath();
        ctx.moveTo(0, WATER_LEVEL);

        // 2. æ³¢ç·šï¼ˆæ³¢æ‰“ã¡ï¼‰
        for (let i = 0; i <= SEGMENTS; i++) {
            const x = GAME_WIDTH / SEGMENTS * i;
            const y = WATER_LEVEL + Math.sin(x * WAVE_FREQUENCY + waterTime) * WAVE_AMPLITUDE;
            ctx.lineTo(x, y);
        }

        // æ³¢ã®ä¸‹ã‚’å¡—ã‚Šã¤ã¶ã—
        ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
        ctx.lineTo(0, GAME_HEIGHT);
        ctx.closePath();
        ctx.fillStyle = waterGrad;
        ctx.fill();

        // 3. æ³¢ã®è¼ªéƒ­ç·šï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰
        ctx.beginPath();
        ctx.moveTo(0, WATER_LEVEL);
        for (let i = 0; i <= SEGMENTS; i++) {
            const x = GAME_WIDTH / SEGMENTS * i;
            const y = WATER_LEVEL + Math.sin(x * WAVE_FREQUENCY + waterTime) * WAVE_AMPLITUDE;
            ctx.lineTo(x, y);
        }
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; // ç™½ã„ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();
        // --- æ°´ã®æç”» çµ‚äº† ---

        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ³
        if (!isGameOver) {
            
            // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ï¼ˆäºˆæ¸¬ç·šï¼‰
            if (currentFruit && isClickable) {
                const x = currentFruit.position.x;
                
                ctx.save();
                ctx.strokeStyle = 'rgba(255,255,255,0.6)'; // ç™½è‰²
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                // äºˆæ¸¬ç·šã¯æ°´é¢ã‹ã‚‰ä¸‹ã¾ã§å¼•ã
                ctx.moveTo(x, GAME_OVER_LINE_Y); 
                ctx.lineTo(x, GAME_HEIGHT);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }
        }

        // ã‚«ãƒ©ãƒ•ãƒ«ãƒœãƒ¼ãƒ«æç”»
        bodies.forEach(body => {
            if (body.render.visible === false) return;
            if (body.circleRadius) {
                const index = parseInt(body.label);
                const f = BALLS[index];
                if (f) {
                    drawBALLShape(ctx, body.position.x, body.position.y, body.circleRadius, f);
                }
            }
        });
        
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°ã¨æç”»
        particles = particles.filter(p => {
            const alive = p.update();
            if (alive) p.draw(ctx);
            return alive;
        });

        Engine.update(engine, Math.min(delta, 16.67));
        requestAnimationFrame(renderLoop);
    })();
	
	// ğŸ”Š åˆå›ã‚¿ãƒƒãƒ—ã§BGMé–‹å§‹ï¼ˆè‡ªå‹•å†ç”Ÿãƒ–ãƒ­ãƒƒã‚¯å¯¾ç­–ï¼‰
    window.addEventListener("pointerdown", () => {
    bgm.play().catch(() => {});
    }, { once: true });


    // åˆæœŸå®Ÿè¡Œ
    fillQueue();
    drawNextRow();
    drawEvolutionRing();
    createCurrentFruit();
</script>
</body>
</html>